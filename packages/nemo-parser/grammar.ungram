Root = TopLevel*

// TopLevel
TopLevel
  = TopImport
  | TopLet
  | TopStruct
  | TopFn

TopImport = 'import' ImpInternal ':' Type 'from' ImpExternal
ImpInternal = 'ident'
ImpExternal = 'ident'

TopLet = 'let' 'ident' ':' Type '=' Expr

TopStruct = 'struct' 'upper_ident' '{' StructField* '}'
StructField = 'ident' ':' Type

TopFn = 'fn' 'ident' ParamList '=' body:EBlock
ParamList = Param*
Param = 'ident' ':' Type

// Types
Type
  = TyInt
  | TyFloat
  | TyBool
  | TyUnit
  | TyArray
  | TyCons
  | TyFn

TyInt = 'i32'
TyFloat = 'f32'
TyBool = 'bool'
TyUnit = 'unit'
TyArray = '[' elem:Type ']'
TyCons = 'upper_ident'
// TODO: Needs wrapper for return type
TyFn = 'fn' '(' arguments:Type* ')' '->' result:Type

// Literals
Literal = LitBool | LitFloat | LitInt

LitInt = 'int_lit'
LitBool = 'true' | 'false'
LitFloat = 'float_lit'

// Expressions

Expr
  = ELit
  | EVar
  | EArray
  | EBlock

ELit = Literal
EVar = 'ident'
EArray = '[' Expr* ']'
EParen = '(' Expr ')'
// TODO: Needs custom impl
EArrayIdx = Expr '[' index:Expr ']'
// TODO: Needs custom impl
ECall = Expr '(' Expr* ')'
// TODO: Needs custom impl
EBinary = lhs:Expr op:BinOp rhs:Expr
EStruct = 'ident' '{' EStructField* '}'
EStructIdx = Expr '.' 'ident'
// TODO: Needs custom impl
EIf = 'if' condition:Expr then_branch:EBlock 'else' else_branch:EBlock
EBlock = '{' Declaration* '}'

// TODO
BinOp = '='

EStructField = 'upper_ident' '=' Expr

// Declarations
Declaration
  = DLet
  | DSet
  | DWhile
  | DExpr

DLet = 'let' 'ident' (':' Type)? '=' Expr
DSet = 'set' SetTarget '=' Expr
DWhile = 'while' Expr EBlock
DExpr = Expr

SetTarget = 'ident' SetIndirection*
SetIndirection = SetStruct | SetArray
SetStruct = '.' 'ident'
SetArray = '[' Expr ']'

global _ = 0
global _ = 4242
global _ = true
global _ = false
global _ = 0.0
global _ = 0.1234
global _ = 1234.1234

// ---

global _ : i32 = 0
global _ : f32 = 0
global _ : bool = 0
global _ : unit = 0
global _ : Struct = 0
global _ : [i32] = 0
global _ : [[Struct]] = 0
global _ : fn() -> unit = 0
global _ : fn(i32) -> f32 = 0
global _ : fn(i32, f32, fn(i32) -> i32) -> f32 = 0

// ---

global _ = []
global _ = [1]
global _ = [1, 2]
global _ = [1, 2,]
global _ = [[1], []]

// ---

global _ = x[1]
global _ = x[x[x]]
global _ = [1, 2][0]
global _ = [[1]][0][0]

// ---

global _ = Vec { }
global _ = Vec { x = 10 }
global _ = Vec { x = 10, y = 1.0 }
global _ = Vec { x = 10, y = 1.0, }

// ---

global _ = v.x
global _ = v.x.y
global _ = v[0].y

// ---

global _ = f()
global _ = f(1)
global _ = f(1, 2,)
global _ = f(1, f(2))
global _ = x.f()
global _ = x[1].f()
global _ = f(1)(x)

// ---

global _ = @array_len([])
global _ = @array_new(1, 2)

// ---

global _ = if true { 1 } else { 3 }

// ---

global _ = {}
global _ = {1}
global _ = {
    1;
    x;
    2
}

// ---

global _ = 1 + 1
global _ = 1 + 1 + 1
global _ = 1 * 1 + 1
global _ = 1 + 1 * 1
global _ = 1 <= 2 && 1 < 1 || 1 >= 3 && 3 > 4 || 1 == 1 || 1 != 2
global _ = 1 + x.y
global _ = f32_abs(delta_x) > f32_abs(delta_y)

// ---

global _ = {
    let x = 1;
    let y : i32 = 10;
    set x = 1;
    set x[0] = 1;
    set x.y = 1;
    set x[0].y = 1;
    set x.y[0] = 1;
    while x {
      1;
      2
    };
}

// ---

variant Rope {
  struct Leaf { char : i32 },
  struct Node {
    children : [Rope],
    len : i32
  },
}

global _ = Rope::Leaf { char = 2 }
global _ = Rope::Node { children = [], len = 10 }
global _ = Rope::Node { children = [], len = 10 }

global _ = match rope {
  Rope::Leaf leaf => { leaf.char },
  Rope::Node node => { node.children + node.len },
}


// ---

import internal : fn (i32, f32) -> i32 from external

struct Vec {
  x : f32,
  y : f32,
}

global x = 10
global y : f32 = 10.0

fn main() = {

}

fn add(x : i32, y : i32) : i32 = {
    x + y
}

// ---

fn add_particle(p : Particle) = {
  set particles.buffer[particles.watermark] = p;
  set particles.watermark =
    i32_rem_s(particles.watermark + 1, @array_len(particles.buffer))
}

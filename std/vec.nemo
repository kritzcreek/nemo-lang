module vec
exports (Vec, new, with_capacity, index, set_index, push, pop, extend, subvec, for_each, to_array)

use prim
use option

struct Vec[a] {
  zero : a,
  len : I32,
  buf : Array[a],
}

fn new[a](zero : a) -> Vec[a] {
  Vec {
    zero = zero,
    len = 0,
    buf = [],
  }
}

fn with_capacity[a](zero : a, capacity : I32) -> Vec[a] {
  Vec {
    zero = zero,
    len = 0,
    buf = prim::array_new(zero, capacity),
  }
}

fn capacity[a](vec : Vec[a]) -> I32 {
  prim::array_len(vec.buf)
}

fn grow[a](vec : Vec[a], new_len : I32) {
  when capacity(vec) >= new_len {
    return {};
  };
  let new_capacity = if vec.len < 4 { 4 } else { vec.len };
  while new_capacity < new_len {
    set new_capacity = new_capacity * 2;
  };
  let new_buf = prim::array_new(vec.zero, new_capacity);
  let i = 0;
  while i < vec.len {
    set new_buf[i] = vec.buf[i];
    set i = i + 1;
  };

  set vec.buf = new_buf;
}

fn index[a](vec : Vec[a] ix : I32) -> a {
  when vec.len <= ix {
    prim::panic();
  };
  vec.buf[ix]
}

fn set_index[a](vec : Vec[a] ix : I32, elem : a) {
  when vec.len <= ix {
    prim::panic();
  };
  set vec.buf[ix] = elem;
}

fn push[a](vec : Vec[a], elem : a) {
  grow(vec, vec.len + 1);
  set vec.buf[vec.len] = elem;
  set vec.len = vec.len + 1;
}

fn pop[a](vec : Vec[a]) -> option::Option[a] {
  if vec.len == 0 {
    return option::none();
  } else {
    set vec.len = vec.len - 1;
    let elem = vec.buf[vec.len];
    set vec.buf[vec.len] = vec.zero;
    return option::some(elem);
  };
}

fn extend[a](vec : Vec[a], other : Vec[a]) {
  grow(vec, vec.len + other.len);
  let i = 0;
  while i < other.len {
    set vec.buf[vec.len + i] = other.buf[i];
    set i = i + 1;
  };
  set vec.len = vec.len + other.len;
}

fn subvec[a](vec : Vec[a], start : I32, len : I32) -> Vec[a] {
  when start < 0 || len < 0 || start + len >= vec.len {
    prim::panic()
  };
  let new_vec = with_capacity(vec.zero, len);
  prim::array_copy(new_vec.buf, 0, vec.buf, start, len);
  set new_vec.len = len;
  new_vec
}

fn for_each[a](vec : Vec[a], f : fn (a) -> Unit) {
  let i = 0;
  let len = vec.len;
  while i < len {
    f(vec.buf[i]);
    set i = i + 1;
  };
}

fn to_array[a](vec : Vec[a]) -> Array[a] {
  let res = prim::array_new(vec.zero, vec.len);
  prim::array_copy(res, 0, vec.buf, 0, vec.len);
  res
}

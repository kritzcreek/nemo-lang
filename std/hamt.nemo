use io
use string
use option

struct Hamt[a] {
  root : Node[a],
}

variant Node[a] {
  struct Mapped { bitmap : I32, nodes : Array[Node[a]] },
  struct Leaf { hash : I32, value : a },
}

fn new[a]() -> Hamt[a] {
  Hamt { root = Node::Mapped { bitmap = 0, nodes = [] } }
}

fn mask(hash : I32, shift : I32) -> I32 {
  i32_shr_u(hash, i32_and(shift, 31))
}

fn bitpos(hash : I32, shift : I32) -> I32 {
   i32_shl(1, mask(hash, shift))
}

fn index(bitmap : I32, pos : I32) -> I32 {
  i32_popcnt(i32_and(bitmap, (pos - 1)))
}

fn get[a](hamt : Hamt[a], hash : I32) -> option::Option[a] {
  match get_with_anchor(hamt.root, 0, hash).payload {
    GetResultPayload::Success s => {
      match s.node {
        Node::Leaf l => {
          option::Option::Some { val = l.value }
        },
        Node::Mapped _ => {
          option::Option::None {}
        },
      }
    },
    GetResultPayload::Missing _ => { option::Option::None {} },
    GetResultPayload::Conflict _ => { option::Option::None {} },
  };
}

fn add[a](hamt : Hamt[a], hash : I32, value : a) {
  let get_result = get_with_anchor(hamt.root, 0, hash);
  match get_result.payload {
    GetResultPayload::Missing _ => {
      match get_result.anchor {
        Node::Mapped n => {
          let pos = bitpos(hash, get_result.shift);
          set n.bitmap = i32_or(n.bitmap, pos);
          let ix = index(n.bitmap, pos);
          set n.nodes = insert_node(n.nodes, ix, Node::Leaf { hash = hash, value = value });
        }
      }
    },
    GetResultPayload::Success s => {
      match s.node {
        Node::Leaf l => {
          set l.value = value;
        }
      }
    },
    GetResultPayload::Conflict c => {
      match c.node {
        Node::Leaf l => {
          match get_result.anchor {
            Node::Mapped n => {
              let pos = bitpos(hash, get_result.shift);
              let ix = index(n.bitmap, pos);
              let new_node = merge_leafs(get_result.shift + 5, l.hash, l.value, hash, value);
              set n.nodes[ix] = new_node;
            }
          }
        }
      }
    }
  };
}

fn remove[a](hamt : Hamt[a], hash : I32) {
  let _ = remove_rec(hamt.root, 0, hash);
}

fn merge_leafs[a](shift : I32, h1 : I32, v1 : a, h2 : I32, v2 : a) -> Node[a] {
  let next_pos1 = bitpos(h1, shift);
  let next_pos2 = bitpos(h2, shift);
  if next_pos1 != next_pos2 {
    let bitmap = i32_or(next_pos1, next_pos2);
    let nodes : Array[Node[a]] = if next_pos1 < next_pos2 {
      [Node::Leaf { hash = h1, value = v1 }, Node::Leaf { hash = h2, value = v2 }]
    } else {
      [Node::Leaf { hash = h2, value = v2 }, Node::Leaf { hash = h1, value = v1 }]
    };
    Node::Mapped { bitmap = bitmap, nodes = nodes }
  } else {
    let bitmap = next_pos1;
    let newNode = merge_leafs(shift + 5, h1, v1, h2, v2);
    Node::Mapped { bitmap = bitmap, nodes = [newNode] }
  };
}

variant RemoveResult[a] {
  struct Success {
    // Guaranteed Leaf
    node : Node[a]
  },
  struct NotFound {},
  struct Gathered {
    // Guaranteed Leaf
    new_node : Node[a],
    // Guaranteed Leaf
    removed : Node[a],
  },
}

fn remove_rec[a](node : Node[a], shift : I32, hash : I32) -> RemoveResult[a] {
  match node {
    Node::Mapped node => {
      let pos = bitpos(hash, shift);
      if i32_and(pos, node.bitmap) == 0 {
        return RemoveResult::NotFound {};
      } else {};
      let ix = index(node.bitmap, pos);
      let next_node = node.nodes[ix] ;
      match next_node {
        Node::Mapped n => {
          let res = remove_rec(next_node, shift + 5, hash);
          match res {
            RemoveResult::Gathered gathered => {
              if shift != 0 && i32_popcnt(n.bitmap) == 1 {
                res
              } else {
                set n.nodes[ix] = gathered.new_node;
                RemoveResult::Success { node = gathered.removed };
              }
            },
            _ => { res },
          };
        },
        Node::Leaf l => {
          if hash != l.hash {
            RemoveResult::NotFound {};
          } else {
            let rows = i32_popcnt(node.bitmap);
            // We never gather the root node
            if rows == 1 && shift == 0 {
              set node.bitmap = 0;
              set node.nodes = [];
              return RemoveResult::Success { node = next_node }
            } else {};

            if rows == 2 {
              let other = if ix == 0 { node.nodes[1] } else { node.nodes[0] };
              match other {
                Node::Leaf l => {
                  if shift != 0 {
                    return RemoveResult::Gathered { new_node = other, removed = next_node };
                  } else {};
                },
                _ => {},
              };
              set node.bitmap = i32_and(node.bitmap, i32_xor(pos, 0 - 1));
              set node.nodes = [other];
              RemoveResult::Success { node = next_node }
            } else {
              let new_nodes = remove_node(node.nodes, ix);
              set node.bitmap = i32_and(node.bitmap, i32_xor(pos, 0 - 1));
              set node.nodes = new_nodes;
              RemoveResult::Success { node = next_node }
            };
          }
        },
      };
    }
  }
}

fn remove_node[a](as : Array[a], ix : I32) -> Array[a] {
  let old_len = array_len#[a](as);
  if old_len == 1 {
    []
  } else {
    let res = array_new#[a](as[0], old_len - 1);
    array_copy#[a](res, 0, as, 0, ix);
    array_copy#[a](res, ix, as, ix + 1, old_len - ix - 1);
    res
  }
}

fn insert_node[a](as : Array[a], ix : I32, elem : a) -> Array[a] {
  let old_len = array_len#[a](as);
  if old_len == 0 {
    [elem]
  } else {
    let res = array_new#[a](elem, old_len + 1);
    array_copy#[a](res, 0, as, 0, ix);
    array_copy#[a](res, ix + 1, as, ix, old_len - ix);
    res
  }
}

struct GetResult[a] {
  shift : I32,
  anchor : Node[a],
  payload : GetResultPayload[a]
}

variant GetResultPayload[a] {
  struct Success { node : Node[a] },
  struct Conflict { node : Node[a] },
  struct Missing {},
}

fn get_with_anchor[a](
  // Guaranteed to be Mapped
  node : Node[a],
  shift : I32, hash : I32
) -> GetResult[a] {
  let pos = bitpos(hash, shift);
  match node {
    Node::Mapped anchor => {
      if i32_and(anchor.bitmap, pos) == 0 {
        GetResult { shift = shift, anchor = node, payload = GetResultPayload::Missing {} };
      } else {
        let ix = index(anchor.bitmap, pos);
        let n = anchor.nodes[ix];
        match n {
          Node::Mapped anchor => {
            get_with_anchor(n, shift + 5, hash)
          },
          Node::Leaf leaf => {
            if leaf.hash == hash {
              GetResult { shift = shift, anchor = node, payload = GetResultPayload::Success { node = n } };
            } else {
              GetResult { shift = shift, anchor = node, payload = GetResultPayload::Conflict { node = n } };
            }
          },
        };
      };
    }
  }
}

fn print_array(as : Array[I32]) {
  io::println_bytes("BEGIN");
  let i = 0;
  while i < array_len#[I32](as) {
    io::print_int(as[i]);
    set i = i + 1;
  };
  io::println_bytes("END");
}

fn main() -> I32 {
  let hamt : Hamt[I32] = new();
  add(hamt, 0, 0);
  remove(hamt, 0);
  match get(hamt, 1) {
    option::Option::Some s => {
      io::println_bytes("Found");
      io::print_int(s.val);
      10
    },
    option::Option::None _ => {
      io::println_bytes("Not Found");
      0
    },
  }
}
